// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "User.pbobjc.h"
 #import "Common.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - UserRoot

@implementation UserRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - UserRoot_FileDescriptor

static GPBFileDescriptor *UserRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - UserRegisterRequest

@implementation UserRegisterRequest

@dynamic hasUsername, username;

typedef struct UserRegisterRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *username;
} UserRegisterRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = UserRegisterRequest_FieldNumber_Username,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserRegisterRequest__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserRegisterRequest class]
                                     rootClass:[UserRoot class]
                                          file:UserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserRegisterRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessageSendRequest

@implementation MessageSendRequest

@dynamic targetsArray, targetsArray_Count;
@dynamic hasMessage, message;

typedef struct MessageSendRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *targetsArray;
  MessageInfo *message;
} MessageSendRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetsArray",
        .dataTypeSpecific.className = NULL,
        .number = MessageSendRequest_FieldNumber_TargetsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MessageSendRequest__storage_, targetsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageInfo),
        .number = MessageSendRequest_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageSendRequest__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageSendRequest class]
                                     rootClass:[UserRoot class]
                                          file:UserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageSendRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessageNotifyRequest

@implementation MessageNotifyRequest

@dynamic hasMessage, message;

typedef struct MessageNotifyRequest__storage_ {
  uint32_t _has_storage_[1];
  MessageInfo *message;
} MessageNotifyRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "message",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageInfo),
        .number = MessageNotifyRequest_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageNotifyRequest__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageNotifyRequest class]
                                     rootClass:[UserRoot class]
                                          file:UserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageNotifyRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeviceProto

@implementation DeviceProto

@dynamic hasDeviceId, deviceId;
@dynamic hasUserId, userId;
@dynamic hasStatus, status;
@dynamic hasAppVersion, appVersion;
@dynamic hasDeviceName, deviceName;
@dynamic hasDeviceOs, deviceOs;
@dynamic hasDeviceType, deviceType;
@dynamic hasIp, ip;
@dynamic hasLocation, location;
@dynamic hasIsp, isp;
@dynamic hasNetStatus, netStatus;
@dynamic hasOnline, online;
@dynamic hasLastCheck, lastCheck;
@dynamic hasLastLogin, lastLogin;
@dynamic hasCreated, created;

typedef struct DeviceProto__storage_ {
  uint32_t _has_storage_[1];
  uint32_t status;
  uint32_t deviceOs;
  uint32_t deviceType;
  uint32_t lastCheck;
  uint32_t lastLogin;
  uint32_t created;
  NSString *deviceId;
  NSString *userId;
  NSString *appVersion;
  NSString *deviceName;
  NSString *ip;
  NSString *location;
  NSString *isp;
  NSString *netStatus;
} DeviceProto__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = DeviceProto_FieldNumber_DeviceId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeviceProto__storage_, deviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = DeviceProto_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DeviceProto__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = DeviceProto_FieldNumber_Status,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DeviceProto__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "appVersion",
        .dataTypeSpecific.className = NULL,
        .number = DeviceProto_FieldNumber_AppVersion,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DeviceProto__storage_, appVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceName",
        .dataTypeSpecific.className = NULL,
        .number = DeviceProto_FieldNumber_DeviceName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DeviceProto__storage_, deviceName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceOs",
        .dataTypeSpecific.className = NULL,
        .number = DeviceProto_FieldNumber_DeviceOs,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DeviceProto__storage_, deviceOs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.className = NULL,
        .number = DeviceProto_FieldNumber_DeviceType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DeviceProto__storage_, deviceType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = DeviceProto_FieldNumber_Ip,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DeviceProto__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "location",
        .dataTypeSpecific.className = NULL,
        .number = DeviceProto_FieldNumber_Location,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(DeviceProto__storage_, location),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isp",
        .dataTypeSpecific.className = NULL,
        .number = DeviceProto_FieldNumber_Isp,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(DeviceProto__storage_, isp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "netStatus",
        .dataTypeSpecific.className = NULL,
        .number = DeviceProto_FieldNumber_NetStatus,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(DeviceProto__storage_, netStatus),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "online",
        .dataTypeSpecific.className = NULL,
        .number = DeviceProto_FieldNumber_Online,
        .hasIndex = 11,
        .offset = 12,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "lastCheck",
        .dataTypeSpecific.className = NULL,
        .number = DeviceProto_FieldNumber_LastCheck,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(DeviceProto__storage_, lastCheck),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "lastLogin",
        .dataTypeSpecific.className = NULL,
        .number = DeviceProto_FieldNumber_LastLogin,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(DeviceProto__storage_, lastLogin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "created",
        .dataTypeSpecific.className = NULL,
        .number = DeviceProto_FieldNumber_Created,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(DeviceProto__storage_, created),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeviceProto class]
                                     rootClass:[UserRoot class]
                                          file:UserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeviceProto__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserProto

@implementation UserProto

@dynamic hasUserId, userId;
@dynamic hasPhone, phone;
@dynamic hasNickname, nickname;
@dynamic hasStatus, status;
@dynamic hasRole, role;
@dynamic hasCreated, created;
@dynamic hasRemainTime, remainTime;

typedef struct UserProto__storage_ {
  uint32_t _has_storage_[1];
  uint32_t status;
  uint32_t role;
  uint32_t created;
  uint32_t remainTime;
  NSString *userId;
  NSString *phone;
  NSString *nickname;
} UserProto__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = UserProto_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserProto__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "phone",
        .dataTypeSpecific.className = NULL,
        .number = UserProto_FieldNumber_Phone,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserProto__storage_, phone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickname",
        .dataTypeSpecific.className = NULL,
        .number = UserProto_FieldNumber_Nickname,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserProto__storage_, nickname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = UserProto_FieldNumber_Status,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserProto__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "role",
        .dataTypeSpecific.className = NULL,
        .number = UserProto_FieldNumber_Role,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UserProto__storage_, role),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "created",
        .dataTypeSpecific.className = NULL,
        .number = UserProto_FieldNumber_Created,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UserProto__storage_, created),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "remainTime",
        .dataTypeSpecific.className = NULL,
        .number = UserProto_FieldNumber_RemainTime,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(UserProto__storage_, remainTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserProto class]
                                     rootClass:[UserRoot class]
                                          file:UserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserProto__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - INIT_RESPONSE

@implementation INIT_RESPONSE

@dynamic hasBaseResponse, baseResponse;
@dynamic hasDeviceResponse, deviceResponse;
@dynamic hasUserResponse, userResponse;

typedef struct INIT_RESPONSE__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  DeviceProto *deviceResponse;
  UserProto *userResponse;
} INIT_RESPONSE__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = INIT_RESPONSE_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(INIT_RESPONSE__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deviceResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(DeviceProto),
        .number = INIT_RESPONSE_FieldNumber_DeviceResponse,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(INIT_RESPONSE__storage_, deviceResponse),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(UserProto),
        .number = INIT_RESPONSE_FieldNumber_UserResponse,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(INIT_RESPONSE__storage_, userResponse),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[INIT_RESPONSE class]
                                     rootClass:[UserRoot class]
                                          file:UserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(INIT_RESPONSE__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\014\000\002\016\000\003\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NEED_REGISTER_DEVICE_RESPONSE

@implementation NEED_REGISTER_DEVICE_RESPONSE

@dynamic hasBaseResponse, baseResponse;

typedef struct NEED_REGISTER_DEVICE_RESPONSE__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} NEED_REGISTER_DEVICE_RESPONSE__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = NEED_REGISTER_DEVICE_RESPONSE_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NEED_REGISTER_DEVICE_RESPONSE__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NEED_REGISTER_DEVICE_RESPONSE class]
                                     rootClass:[UserRoot class]
                                          file:UserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NEED_REGISTER_DEVICE_RESPONSE__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DEVICE_REGISTER_REQUEST

@implementation DEVICE_REGISTER_REQUEST

@dynamic hasDeviceId, deviceId;
@dynamic hasAppVersion, appVersion;
@dynamic hasDeviceName, deviceName;
@dynamic hasDeviceOs, deviceOs;
@dynamic hasDeviceType, deviceType;

typedef struct DEVICE_REGISTER_REQUEST__storage_ {
  uint32_t _has_storage_[1];
  uint32_t deviceOs;
  uint32_t deviceType;
  NSString *deviceId;
  NSString *appVersion;
  NSString *deviceName;
} DEVICE_REGISTER_REQUEST__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = DEVICE_REGISTER_REQUEST_FieldNumber_DeviceId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DEVICE_REGISTER_REQUEST__storage_, deviceId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "appVersion",
        .dataTypeSpecific.className = NULL,
        .number = DEVICE_REGISTER_REQUEST_FieldNumber_AppVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DEVICE_REGISTER_REQUEST__storage_, appVersion),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceName",
        .dataTypeSpecific.className = NULL,
        .number = DEVICE_REGISTER_REQUEST_FieldNumber_DeviceName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DEVICE_REGISTER_REQUEST__storage_, deviceName),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceOs",
        .dataTypeSpecific.className = NULL,
        .number = DEVICE_REGISTER_REQUEST_FieldNumber_DeviceOs,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DEVICE_REGISTER_REQUEST__storage_, deviceOs),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.className = NULL,
        .number = DEVICE_REGISTER_REQUEST_FieldNumber_DeviceType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DEVICE_REGISTER_REQUEST__storage_, deviceType),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DEVICE_REGISTER_REQUEST class]
                                     rootClass:[UserRoot class]
                                          file:UserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DEVICE_REGISTER_REQUEST__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DEVICE_REGISTER_RESPONSE

@implementation DEVICE_REGISTER_RESPONSE

@dynamic hasBaseResponse, baseResponse;
@dynamic hasDeviceResponse, deviceResponse;

typedef struct DEVICE_REGISTER_RESPONSE__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  DeviceProto *deviceResponse;
} DEVICE_REGISTER_RESPONSE__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = DEVICE_REGISTER_RESPONSE_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DEVICE_REGISTER_RESPONSE__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deviceResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(DeviceProto),
        .number = DEVICE_REGISTER_RESPONSE_FieldNumber_DeviceResponse,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DEVICE_REGISTER_RESPONSE__storage_, deviceResponse),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DEVICE_REGISTER_RESPONSE class]
                                     rootClass:[UserRoot class]
                                          file:UserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DEVICE_REGISTER_RESPONSE__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\014\000\002\016\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DEVICE_UPDATE_REQUEST

@implementation DEVICE_UPDATE_REQUEST

@dynamic hasDeviceId, deviceId;
@dynamic hasUserId, userId;
@dynamic hasStatus, status;
@dynamic hasAppVersion, appVersion;
@dynamic hasDeviceName, deviceName;
@dynamic hasDeviceOs, deviceOs;
@dynamic hasDeviceType, deviceType;
@dynamic hasNetStatus, netStatus;

typedef struct DEVICE_UPDATE_REQUEST__storage_ {
  uint32_t _has_storage_[1];
  uint32_t status;
  uint32_t deviceOs;
  uint32_t deviceType;
  NSString *deviceId;
  NSString *userId;
  NSString *appVersion;
  NSString *deviceName;
  NSString *netStatus;
} DEVICE_UPDATE_REQUEST__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = DEVICE_UPDATE_REQUEST_FieldNumber_DeviceId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DEVICE_UPDATE_REQUEST__storage_, deviceId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = DEVICE_UPDATE_REQUEST_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DEVICE_UPDATE_REQUEST__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = DEVICE_UPDATE_REQUEST_FieldNumber_Status,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DEVICE_UPDATE_REQUEST__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "appVersion",
        .dataTypeSpecific.className = NULL,
        .number = DEVICE_UPDATE_REQUEST_FieldNumber_AppVersion,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DEVICE_UPDATE_REQUEST__storage_, appVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceName",
        .dataTypeSpecific.className = NULL,
        .number = DEVICE_UPDATE_REQUEST_FieldNumber_DeviceName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DEVICE_UPDATE_REQUEST__storage_, deviceName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceOs",
        .dataTypeSpecific.className = NULL,
        .number = DEVICE_UPDATE_REQUEST_FieldNumber_DeviceOs,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DEVICE_UPDATE_REQUEST__storage_, deviceOs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.className = NULL,
        .number = DEVICE_UPDATE_REQUEST_FieldNumber_DeviceType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DEVICE_UPDATE_REQUEST__storage_, deviceType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "netStatus",
        .dataTypeSpecific.className = NULL,
        .number = DEVICE_UPDATE_REQUEST_FieldNumber_NetStatus,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DEVICE_UPDATE_REQUEST__storage_, netStatus),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DEVICE_UPDATE_REQUEST class]
                                     rootClass:[UserRoot class]
                                          file:UserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DEVICE_UPDATE_REQUEST__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DEVICE_UPDATE_RESPONSE

@implementation DEVICE_UPDATE_RESPONSE

@dynamic hasBaseResponse, baseResponse;
@dynamic hasDeviceResponse, deviceResponse;

typedef struct DEVICE_UPDATE_RESPONSE__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  DeviceProto *deviceResponse;
} DEVICE_UPDATE_RESPONSE__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = DEVICE_UPDATE_RESPONSE_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DEVICE_UPDATE_RESPONSE__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deviceResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(DeviceProto),
        .number = DEVICE_UPDATE_RESPONSE_FieldNumber_DeviceResponse,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DEVICE_UPDATE_RESPONSE__storage_, deviceResponse),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DEVICE_UPDATE_RESPONSE class]
                                     rootClass:[UserRoot class]
                                          file:UserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DEVICE_UPDATE_RESPONSE__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\014\000\002\016\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DEVICE_DELETE_REQUEST

@implementation DEVICE_DELETE_REQUEST

@dynamic hasDeviceId, deviceId;

typedef struct DEVICE_DELETE_REQUEST__storage_ {
  uint32_t _has_storage_[1];
  NSString *deviceId;
} DEVICE_DELETE_REQUEST__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = DEVICE_DELETE_REQUEST_FieldNumber_DeviceId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DEVICE_DELETE_REQUEST__storage_, deviceId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DEVICE_DELETE_REQUEST class]
                                     rootClass:[UserRoot class]
                                          file:UserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DEVICE_DELETE_REQUEST__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DEVICE_DELETE_RESPONSE

@implementation DEVICE_DELETE_RESPONSE

@dynamic hasBaseResponse, baseResponse;

typedef struct DEVICE_DELETE_RESPONSE__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} DEVICE_DELETE_RESPONSE__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = DEVICE_DELETE_RESPONSE_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DEVICE_DELETE_RESPONSE__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DEVICE_DELETE_RESPONSE class]
                                     rootClass:[UserRoot class]
                                          file:UserRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DEVICE_DELETE_RESPONSE__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
